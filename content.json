{"meta":{"title":"猿视界","subtitle":"不仅要明白是什么，更要清楚为什么。","description":"个人技术博客","author":"冯生伟","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-06-14T06:59:50.000Z","updated":"2017-06-14T06:59:50.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-14T06:40:47.000Z","updated":"2017-06-14T06:47:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"layout: tagsnoDate: true comments: false"}],"posts":[{"title":"iOS11适配之：0代码实现导航栏UIBarButtonItem间距调整","slug":"iOS11适配之：0代码实现导航栏UIBarButtonItem间距调整","date":"2017-09-21T12:48:18.000Z","updated":"2017-09-23T02:56:01.000Z","comments":true,"path":"2017/09/21/iOS11适配之：0代码实现导航栏UIBarButtonItem间距调整/","link":"","permalink":"http://yoursite.com/2017/09/21/iOS11适配之：0代码实现导航栏UIBarButtonItem间距调整/","excerpt":"","text":"最新版Xcode9在20号已经提供下载了，Stone哥哥作为一个凡事喜欢走在前面的人（不要脸了，哈哈哈，不过Stone哥哥的手机系统确实是从iOS 11第一个beta版开始使用的，体验过各种bug煎熬，终于熬到正式版了，内牛满面…），当然第一时间就升级了，下载安装完5个多鸡的安装包，Stone哥哥激动的打开了目前正在开发的项目，Command+B，成功编译！但是当我点击运行，在APP中跳转几个页面后，忽然注意到导航栏…WTF!!! 这间距可就大得有点惊人哈，顿时把Stone哥哥脸都吓白了… 于是Stone哥哥赶紧把原来用于调整间距的BarButton的负宽度一口气调到-50，[UIBarButtonItem zg_fixedSpaceWithWidth:-50]; 1234567+ (UIBarButtonItem *)zg_fixedSpaceWithWidth:(CGFloat)width &#123; UIBarButtonItem *spaceBarButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; spaceBarButton.width = width; return spaceBarButton;&#125; 然鹅…这 并没什么卵用！并没什么卵用！并没什么卵用！ 有点意思，就喜欢可以折腾一番的问题，所以我们还是和以往一样，从发现问题开始，冷静滴一步一步来把问题攻破。 一. 找出布局错乱的原因既然老一套调整间距的方式已经不起作用，那要么iOS 11增加了一种新的用于调整间距的UIBarButtonItem类型，要么就是整个解析发生变更，图层有变化，看图层是否有变化这个最直观又方便，所以我们先对图层来一探究竟这是最新的iOS 11导航栏的视图层级结构，好复杂的样子，一个小小的item，叠了这么多层级，而且使用了autoLayout来布局，虽然图层很多，但看起来也很合理的样子，而且基本上就可以确定对item间距的调整方向——更改layout约束条件。忘了iOS 11以前是什么样子了，但感觉有变化，所以我们再来看看iOS 11以前的视图层级结构 还真是不一样，很显然，iOS 11以前系统导航栏的层级结构好简单很多，而且没有使用autoLayout。所有的视图都堆在UINavigationBar上，对比起来，老版本确实不是很合理的样子，心里默默为这个细小的优化点个赞！新版本的调整方向已经确定了，那能不能让老版本也统一呢，也给UINavigationButton也加上约束条件，抛弃fixedSpace类型的UIBarButtonItem。然鹅，这种操作是被禁止的，程序会无情的crash 苹果不允许开发者给UINavigationBar添加约束… 唉！没事，坚强的Stone哥并没有哭，那就分开两种不同的适配方式吧，那我们再来对iOS 11以前的老版本的渲染规则好好了解一番，从前面图“iOS 11以前系统导航栏视图层级结构.png”和Stone哥的一番测试，得出了一下一些结论： 系统自己创建的UINavigationButton内含的图片和标题水平和垂直方向都是居中对齐； UINavigationButton高度上没有撑满整个UINavigationBar的高度，并且没有居中对齐，图中右边的两个item就很明显没在垂直方向对齐； 另外经过一点点微调，UINavigationButton左右两边与屏幕边缘的距离都是15，右边的两个item间距大概为5，固定不可调整； 看到这里，你可能跟我一样想吐槽了，原来iOS 11以前的系统导航栏渲染是这么随意，这里辣鸡…哈哈哈，所以Stone哥得好好的拯救他一下。 现在问题的根源了解得差不多了，也基本有了解决思路，所以是时候进入解决问题的第二步了。 二. 解题思路1. 针对老版本：看到老版本中，系统从UIBarButtonItem到添加到UINavigationBar上的UINavigationButton的转化如此糟糕，而且想要再对其进行修改极其困难，决定要阻断这一层转换，全都创建自己的CustomView，并对其进行对其设置，即添加到左边则左对齐，右边则右对齐，并且高度撑满整个导航栏，总之就是这个customView要弥补前面提到的老版本的所有不足。 2. 针对新版本：前面已经提到，新版本通过改变约束来实现调整，但是具体在什么时候，在哪个地方来调整呢，首先我想到在[UINavigationBar layoutSubviews] 方法里遍历subViews来设置约束，但是subViews里最终遍历到UIStackView的时候，并没有position信息，即不知道这个视图是被添加在了左边还是右边，所以很显然也会需要CustomView，并在其中包含位置信息，既然这样，何不将改变约束的方法放在CustomView的layoutSubviews里呢，减少对一个系统类的修改应该是降低风险降低复杂度的操作吧，哈哈，要在CustomView里设置约束的话，那CustomView还需要包含另外一条信息，就是与它相邻的另外一个CustomView，因为要设置两两之间的间距。 到这里，我们的主角CustomView类就有了两个必须的属性了，一个描述被添加的位置(左或右)的position，一个指向前一个相邻CustomView的属性prevCustomView； 另外要阻断系统对UIBarButtonItem的转换，CustomView还应该增加几个和UIBarButtonItem对应的实例化方法，最终得到了CustomView类的声明如下 123456789101112131415161718192021222324#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSInteger, ZGBarButtonItemPosition) &#123; ZGBarButtonItemPositionLeft, ZGBarButtonItemPositionRight&#125;;typedef NS_ENUM(NSInteger, ZGBarButtonItemType) &#123; ZGBarButtonItemTypeTitle, ZGBarButtonItemTypeImage, ZGBarButtonItemTypeCustomView&#125;;@interface ZGBarButtonItemCustomView : UIView@property (nonatomic, assign) ZGBarButtonItemPosition position;@property (nonatomic, weak) ZGBarButtonItemCustomView *prevCustomView;@property (nonatomic, assign) ZGBarButtonItemType itemType;- (instancetype)initWithTitle:(NSString *)title target:(id)target action:(SEL)action;- (instancetype)initWithImage:(UIImage *)image target:(id)target action:(SEL)action;- (instancetype)initWithCustomView:(UIView *)customView;@end 针对老版本，CustomView 设置对其方式，自适应大小； 针对新版本，CustomView要设置约束； 因为需要添加响应，所以CustomView上应该添加一个button； 另外由于CustomView上的button的图片和文字正常情况下无法随UINavigationBar的tintColor改变，所以还得设置跟随tintColor，图片好说，本身的renderMode渲染模式就支持跟随tintColor改变，但是titleLabel不能，所以还要设置KVO监听UINavigationBar.tintColor的改变，随时更改titleLabel.textColor。所以得到CustomView的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#import &quot;ZGBarButtonItemCustomView.h&quot;#import &quot;UIView+ZGLayoutConstraint.h&quot;#import &quot;ZGNavBarItemSpceMacro.h&quot;@interface ZGBarButtonItemCustomView ()@property (nonatomic, strong) UIButton *button;@property (nonatomic, assign) BOOL fixed;@property (nonatomic, assign) BOOL isLastItem;@property (nonatomic, weak) UINavigationBar *navBar;@end@implementation ZGBarButtonItemCustomView- (instancetype)initWithTitle:(NSString *)title target:(id)target action:(SEL)action &#123; if (self = [super init]) &#123; [self p_setUpButtonWithTitle:title image:nil target:target action:action]; [self p_init]; self.itemType = ZGBarButtonItemTypeTitle; &#125; return self;&#125;- (instancetype)initWithImage:(UIImage *)image target:(id)target action:(SEL)action &#123; if (self = [super init]) &#123; [self p_setUpButtonWithTitle:nil image:image target:target action:action]; [self p_init]; self.itemType = ZGBarButtonItemTypeImage; &#125; return self;&#125;- (instancetype)initWithCustomView:(UIView *)customView &#123; if (self = [super init]) &#123; [self addSubview:customView]; [self setFrame:customView.bounds]; [self setCenter:customView.center]; [self p_init]; self.itemType = ZGBarButtonItemTypeCustomView; &#125; return self;&#125;- (void)dealloc &#123; [self.navBar removeObserver:self forKeyPath:@&quot;tintColor&quot;];&#125;- (void)layoutSubviews &#123; [super layoutSubviews]; if ([[UIDevice currentDevice] systemVersion].floatValue &lt; 11) &#123; [self p_setTitleFollowNavBarTintColorFromView:self]; return; &#125; if (self.fixed) &#123; return; &#125; UIView *adaptorView = [self p_getAdaptorViewFromView:self]; UIView *prevAdaptorView = [self p_getAdaptorViewFromView:self.prevCustomView]; [adaptorView zg_addSizeConstraintWithSize:self.frame.size]; [adaptorView zg_addCenterYConstraint]; CGFloat screenBorderGap = ZG_BAR_ITEM_SCREEN_BORDER_GAP; if (self.position == ZGBarButtonItemPositionLeft) &#123; if (!prevAdaptorView) &#123; [adaptorView zg_addLeftBorderGap:0]; &#125; else &#123; [prevAdaptorView zg_addHorizontalGap:ZG_BAR_ITEM_GAP toView:adaptorView]; &#125; if (self.isLastItem) &#123; UIStackView *stackView = [self p_getStackViewFromView:adaptorView]; for (NSLayoutConstraint *constraint in stackView.superview.constraints) &#123; if ([constraint.firstItem isKindOfClass:[UILayoutGuide class]] &amp;&amp; constraint.firstAttribute == NSLayoutAttributeLeading) &#123; [stackView.superview removeConstraint:constraint]; &#125; &#125; if (self.itemType == ZGBarButtonItemTypeImage) &#123; screenBorderGap -= ZG_BAR_ITEM_LEFT_ICON_EDGE_INSETS; &#125; [stackView zg_addLeftBorderGap:screenBorderGap]; &#125; &#125; else if (self.position == ZGBarButtonItemPositionRight) &#123; if (!prevAdaptorView) &#123; [adaptorView zg_addRightBorderGap:0]; &#125; else &#123; [adaptorView zg_addHorizontalGap:-ZG_BAR_ITEM_GAP toView:prevAdaptorView]; &#125; if (self.isLastItem) &#123; UIStackView *stackView = [self p_getStackViewFromView:adaptorView]; for (NSLayoutConstraint *constraint in stackView.superview.constraints) &#123; if ([constraint.firstItem isKindOfClass:[UILayoutGuide class]] &amp;&amp; constraint.firstAttribute == NSLayoutAttributeTrailing) &#123; [stackView.superview removeConstraint:constraint]; &#125; &#125; if (self.itemType == ZGBarButtonItemTypeImage) &#123; screenBorderGap -= ZG_BAR_ITEM_RIGHT_ICON_EDGE_INSETS; &#125; [stackView zg_addRightBorderGap:-screenBorderGap]; &#125; &#125; [self p_setTitleFollowNavBarTintColorFromView:adaptorView]; self.fixed = YES;&#125;#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; [self.button setTitleColor:self.navBar.tintColor forState:UIControlStateNormal];&#125;#pragma mark - private- (void)p_init &#123; self.isLastItem = YES; self.fixed = NO; self.position = ZGBarButtonItemPositionLeft;&#125;- (void)p_setUpButtonWithTitle:(NSString *)title image:(UIImage *)image target:(id)target action:(SEL)action &#123; [self setButton:[[UIButton alloc] init]]; [self addSubview:self.button]; [self.button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal]; [self.button setTintColor:[UIColor blueColor]]; [self.button setTitle:title forState:UIControlStateNormal]; [self.button.titleLabel setFont:ZG_BAR_ITEM_FONT]; if (image.renderingMode == UIImageRenderingModeAutomatic) &#123; image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; &#125; [self.button setImage:image forState:UIControlStateNormal]; [self.button sizeToFit]; [self.button setFrame:CGRectMake(0, 0, MAX(self.button.frame.size.width, ZG_BAR_ITEM_MIN_WIDTH), 44)]; [self.button addTarget:target action:action forControlEvents:UIControlEventTouchUpInside]; [self setFrame:self.button.bounds];&#125;- (UIView *)p_getAdaptorViewFromView:(UIView *)view &#123; if (!view) &#123; return nil; &#125; UIView *tempView = view; while (![tempView isKindOfClass:NSClassFromString(@&quot;_UITAMICAdaptorView&quot;)] &amp;&amp; tempView.superview) &#123; tempView = tempView.superview; &#125; return tempView;&#125;- (UIStackView *)p_getStackViewFromView:(UIView *)view &#123; if (!view) &#123; return nil; &#125; UIView *tempView = view; while (![tempView isKindOfClass:UIStackView.class] &amp;&amp; tempView.superview) &#123; tempView = tempView.superview; &#125; return (UIStackView *)tempView;&#125;- (UINavigationBar *)p_getNavBarViewFromView:(UIView *)view &#123; if (!view) &#123; return nil; &#125; UIView *tempView = view; while (![tempView isKindOfClass:UINavigationBar.class] &amp;&amp; tempView.superview) &#123; tempView = tempView.superview; &#125; return (UINavigationBar *)tempView;&#125;- (void)p_setTitleFollowNavBarTintColorFromView:(UIView *)view &#123; if (self.itemType == ZGBarButtonItemTypeTitle) &#123; self.navBar = [self p_getNavBarViewFromView:view]; [self.button setTitleColor:self.navBar.tintColor forState:UIControlStateNormal]; [self.navBar addObserver:self forKeyPath:@&quot;tintColor&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; &#125;&#125;#pragma mark - setter &amp; getter- (void)setPosition:(ZGBarButtonItemPosition)position &#123; _position = position; if (self.position == ZGBarButtonItemPositionLeft) &#123; [self.button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentLeft]; &#125; else &#123; [self.button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentRight]; &#125;&#125;- (void)setPrevCustomView:(ZGBarButtonItemCustomView *)prevCustomView &#123; _prevCustomView = prevCustomView; self.prevCustomView.isLastItem = NO;&#125;@end 最后一步就是选择在合适的创建CustomView，和给CustomView设置其他属性了，这个很显然要分别给UIBarButtonItem和UINavigationItem写扩展，切面替换相关方法了，直接上代码： UIBarButtonItem+ZGFixSpace.h 1234567891011121314151617181920212223#import &lt;UIKit/UIKit.h&gt;#import &quot;ZGBarButtonItemCustomView.h&quot;@interface UIBarButtonItem (ZGFixSpace)/* * used before iOS 11 */+ (UIBarButtonItem *)zg_fixedSpaceWithWidth:(CGFloat)width;/* * the side the item be added in (left or right) * used after iOS 11 */- (void)zg_setPosition:(ZGBarButtonItemPosition)position;/* * is the first itme at the current side * used after iOS 11 */- (void)zg_setPrevCustomView:(ZGBarButtonItemCustomView *)prevCustomView;@end UIBarButtonItem+ZGFixSpace.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import &quot;UIBarButtonItem+ZGFixSpace.h&quot;#import &quot;NSObject+ZGRuntime.h&quot;@implementation UIBarButtonItem (ZGFixSpace)+ (UIBarButtonItem *)zg_fixedSpaceWithWidth:(CGFloat)width &#123; UIBarButtonItem *spaceBarButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; spaceBarButton.width = width; return spaceBarButton;&#125;+ (void)load &#123; [self zg_swizzleInstanceMethodWithOriginSel:@selector(initWithTitle:style:target:action:) swizzledSel:@selector(zg_initWithTitle:style:target:action:)]; [self zg_swizzleInstanceMethodWithOriginSel:@selector(initWithImage:style:target:action:) swizzledSel:@selector(zg_initWithImage:style:target:action:)]; [self zg_swizzleInstanceMethodWithOriginSel:@selector(initWithCustomView:) swizzledSel:@selector(zg_initWithCustomView:)];&#125;- (void)zg_setPosition:(ZGBarButtonItemPosition)position &#123; ZGBarButtonItemCustomView *zgCustomView = (ZGBarButtonItemCustomView *)self.customView; zgCustomView.position = position;&#125;- (void)zg_setPrevCustomView:(ZGBarButtonItemCustomView *)prevCustomView &#123; ZGBarButtonItemCustomView *zgCustomView = (ZGBarButtonItemCustomView *)self.customView; zgCustomView.prevCustomView = prevCustomView;&#125;- (instancetype)zg_initWithTitle:(NSString *)title style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action &#123; ZGBarButtonItemCustomView *zgCustomView = [[ZGBarButtonItemCustomView alloc] initWithTitle:title target:target action:action]; return [self zg_initWithCustomView:zgCustomView];&#125;- (instancetype)zg_initWithImage:(UIImage *)image style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action &#123; ZGBarButtonItemCustomView *zgCustomView = [[ZGBarButtonItemCustomView alloc] initWithImage:image target:target action:action]; return [self zg_initWithCustomView:zgCustomView];&#125;- (instancetype)zg_initWithCustomView:(UIView *)customView &#123; ZGBarButtonItemCustomView *zgCustomView = [[ZGBarButtonItemCustomView alloc] initWithCustomView:customView]; return [self zg_initWithCustomView:zgCustomView];&#125;@end 这个扩展主要任务是实现前面说的，阻断系统从UIBarButtonItem到UINavigationButton的转换，实现手段为替换掉UIBarButtonItem的三个实例化方法，在这三个方法中均创建一个CustomView，然后调用原生的initWithCustomView:方法，最终将这个CustomView渲染到UINavigationBar上，这样不会再有UINavigationButton的存在了。 接下来是 UINavigationItem+ZGFixSpace 这个扩展是替换掉在UIViewController中，给viewController.navigationItem添加item的四个方法，给每个item.customView完善前面讲到的position和prevCustomView两个属性，并针对iOS 11以前的版本，在item前添加一个用于调整与屏幕边缘间距的弹簧item，最终就能实现各个版本一样的自适应调整间距的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#import &quot;UINavigationItem+ZGFixSpace.h&quot;#import &quot;NSObject+ZGRuntime.h&quot;#import &quot;UIBarButtonItem+ZGFixSpace.h&quot;#import &quot;ZGNavBarItemSpceMacro.h&quot;@implementation UINavigationItem (ZGFixSpace)+ (void)load &#123; [self zg_swizzleInstanceMethodWithOriginSel:@selector(setLeftBarButtonItem:) swizzledSel:@selector(zg_setLeftBarButtonItem:)]; [self zg_swizzleInstanceMethodWithOriginSel:@selector(setLeftBarButtonItems:) swizzledSel:@selector(zg_setLeftBarButtonItems:)]; [self zg_swizzleInstanceMethodWithOriginSel:@selector(setRightBarButtonItem:) swizzledSel:@selector(zg_setRightBarButtonItem:)]; [self zg_swizzleInstanceMethodWithOriginSel:@selector(setRightBarButtonItems:) swizzledSel:@selector(zg_setRightBarButtonItems:)];&#125;- (void)zg_setLeftBarButtonItem:(UIBarButtonItem *)leftBarButtonItem &#123; if (!leftBarButtonItem || [leftBarButtonItem isKindOfClass:[NSNull class]]) &#123; [self zg_setLeftBarButtonItem:nil]; return; &#125; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 11) &#123; [leftBarButtonItem zg_setPosition:ZGBarButtonItemPositionLeft]; [self zg_setLeftBarButtonItem:leftBarButtonItem]; &#125; else &#123; [self setLeftBarButtonItems:@[leftBarButtonItem]]; &#125;&#125;- (void)zg_setLeftBarButtonItems:(NSArray *)leftBarButtonItems &#123; if (!leftBarButtonItems || [leftBarButtonItems isKindOfClass:[NSNull class]] || leftBarButtonItems.count == 0) &#123; [self zg_setLeftBarButtonItems:nil]; return; &#125; NSMutableArray *items = [NSMutableArray array]; if ([[[UIDevice currentDevice] systemVersion] floatValue] &lt; 11) &#123; ZGBarButtonItemCustomView *customView = (ZGBarButtonItemCustomView *)((UIBarButtonItem *)[leftBarButtonItems firstObject]).customView; CGFloat gap = ZG_BAR_ITEM_SCREEN_BORDER_GAP; if (customView.itemType == ZGBarButtonItemTypeImage) &#123; gap -= ZG_BAR_ITEM_LEFT_ICON_EDGE_INSETS; &#125; [items addObject:[UIBarButtonItem zg_fixedSpaceWithWidth:-(15 - gap)]]; &#125; ZGBarButtonItemCustomView *prevCustomeView = nil; for (NSInteger i=0; i&lt;leftBarButtonItems.count; i++) &#123; UIBarButtonItem *item = [leftBarButtonItems objectAtIndex:i]; [item zg_setPosition:ZGBarButtonItemPositionLeft]; [items addObject:item]; [item zg_setPrevCustomView:prevCustomeView]; prevCustomeView = (ZGBarButtonItemCustomView *)item.customView; &#125; [self zg_setLeftBarButtonItems:items];&#125;- (void)zg_setRightBarButtonItem:(UIBarButtonItem *)rightBarButtonItem &#123; if (!rightBarButtonItem || [rightBarButtonItem isKindOfClass:[NSNull class]]) &#123; [self zg_setRightBarButtonItem:nil]; return; &#125; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 11) &#123; [rightBarButtonItem zg_setPosition:ZGBarButtonItemPositionRight]; [self zg_setRightBarButtonItem:rightBarButtonItem]; &#125; else &#123; [self setRightBarButtonItems:@[rightBarButtonItem]]; &#125;&#125;- (void)zg_setRightBarButtonItems:(NSArray *)rightBarButtonItems &#123; if (!rightBarButtonItems || [rightBarButtonItems isKindOfClass:[NSNull class]] || rightBarButtonItems.count == 0) &#123; [self zg_setRightBarButtonItems:nil]; return; &#125; NSMutableArray *items = [NSMutableArray array]; if ([[[UIDevice currentDevice] systemVersion] floatValue] &lt; 11) &#123; ZGBarButtonItemCustomView *customView = (ZGBarButtonItemCustomView *)((UIBarButtonItem *)[rightBarButtonItems firstObject]).customView; CGFloat gap = ZG_BAR_ITEM_SCREEN_BORDER_GAP; if (customView.itemType == ZGBarButtonItemTypeImage) &#123; gap -= ZG_BAR_ITEM_RIGHT_ICON_EDGE_INSETS; &#125; [items addObject:[UIBarButtonItem zg_fixedSpaceWithWidth:-(15 - gap)]]; &#125; ZGBarButtonItemCustomView *prevCustomeView = nil; for (NSInteger i=0; i&lt;rightBarButtonItems.count; i++) &#123; UIBarButtonItem *item = [rightBarButtonItems objectAtIndex:i]; [item zg_setPosition:ZGBarButtonItemPositionRight]; [item zg_setPrevCustomView:prevCustomeView]; prevCustomeView = (ZGBarButtonItemCustomView *)item.customView; [items addObject:item]; &#125; [self zg_setRightBarButtonItems:items];&#125;@end 另外还有两个工具类扩展第一个 NSObject+ZGRuntime，主要是给实例对象添加了一个交换实例方法的API，前面的两个扩展都是在+ (void)load 方法里调用这个方法来替换掉原生API。 12345- (void)zg_swizzleInstanceMethodWithOriginSel:(SEL)originSel swizzledSel:(SEL)swizzledSel &#123; Method m1 = class_getInstanceMethod([self class], originSel); Method m2 = class_getInstanceMethod([self class], swizzledSel); method_exchangeImplementations(m1, m2);&#125; 第二个 UIView+ZGLayoutConstraint，这个扩展主要是提供了给View添加 尺寸(size)，Y坐标中心点(centerY)，与另一个view的水平间距(horizontalGap)，与父视图边缘间距等的约束的API，在CustomView类的layoutSubviews方法里，iOS 11以后的导航栏就是调用这些方法来添加约束。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#import &quot;UIView+ZGLayoutConstraint.h&quot;@implementation UIView (ZGLayoutConstraint)- (void)zg_addSizeConstraintWithSize:(CGSize)size &#123; [self addConstraint:[NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:size.width]]; [self addConstraint:[NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:size.height]]; &#125;- (void)zg_addCenterYConstraint &#123; [self.superview addConstraint:[NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.superview attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0]];&#125;- (void)zg_addHorizontalGap:(CGFloat)gap toView:(UIView *)view &#123; [self.superview addConstraint:[NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:gap]];&#125;- (void)zg_addLeftBorderGap:(CGFloat)gap &#123; [self.superview addConstraint:[NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:self.superview attribute:NSLayoutAttributeLeading multiplier:1.0 constant:gap]];&#125;- (void)zg_addRightBorderGap:(CGFloat)gap &#123; [self.superview addConstraint:[NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeTrailing relatedBy:NSLayoutRelationEqual toItem:self.superview attribute:NSLayoutAttributeTrailing multiplier:1.0 constant:gap]];&#125;@end 最后，也是最重要的，是便于开发者设置间距的宏文件 ZGNavBarItemSpceMacro 123456789101112#ifndef ZGNavBarItemSpceMacro_h#define ZGNavBarItemSpceMacro_h#define ZG_BAR_ITEM_SCREEN_BORDER_GAP 10 // item到屏幕边缘的距离#define ZG_BAR_ITEM_GAP 5 // item之间的距离 ios11以后生效#define ZG_BAR_ITEM_LEFT_ICON_EDGE_INSETS 6 // 左边item图标图片内边距#define ZG_BAR_ITEM_RIGHT_ICON_EDGE_INSETS 2 // 右边item图标图片内边距#define ZG_BAR_ITEM_MIN_WIDTH 44 // item的最小宽度#define ZG_BAR_ITEM_FONT [UIFont systemFontOfSize:15 weight:UIFontWeightLight] // item字体 ios11以后生效#endif /* ZGNavBarItemSpceMacro_h */ 好啦，全部干活已出，感谢阅读，欢迎去GitHub下载并点星星，爱你哟！！！ 下载源码","categories":[],"tags":[]},{"title":"解决给xib中的button设置倒计时title闪烁的问题","slug":"解决给xib中的button设置倒计时title闪烁的问题","date":"2017-07-04T15:32:17.000Z","updated":"2017-07-04T15:33:06.000Z","comments":true,"path":"2017/07/04/解决给xib中的button设置倒计时title闪烁的问题/","link":"","permalink":"http://yoursite.com/2017/07/04/解决给xib中的button设置倒计时title闪烁的问题/","excerpt":"","text":"以前一直是纯代码编写开发APP，最近开始在项目里使用xib和storyboard，摸索了一整天，终于算基本掌握，但临近下班时，发现了一个很奇葩的问题… 问题场景是这样的: 用户修改绑定手机号时，需要获取验证码，然后按钮显示60秒倒计时，在此期间按钮点击失效，并每隔一秒通过setTile:forState方法更新按钮标题，显示倒计时。 最初的代码 12NSString *title = [NSString stringWithFormat:@&quot;%ld秒后重试&quot;, self.count];[self.getCheckCodeButton setTitle:title forState:UIControlStateDisabled]; 这应该是一个大家非常熟悉的一个常规需求，在以前使用纯代码编写时，不会有任何问题，然而今天的奇葩显现是，每次调用setTitle更新按钮标题时，都会消失一下再显示，看起来就是每个一秒的闪烁显示，特别酷炫（哈哈哈！），然而这并不是此刻我们需要的效果… 怎么办呢？悄悄地去度娘一搜，还真有不少小伙伴也碰到了同样的问题，先来说说网上搜到的方法： 方法一：在storyboard找到这个不老实的button，将他的type设置为Custom，默认是System。 修改之后如下图： 很不幸的是，这种最简单的操作方式，在我这里 并没有奏效 … 并没有奏效 … 并没有奏效 !!!!!!幸好网络资源棒棒哒，很快我又找到了另一种方法。 方法二：这个方法虽然奏效，但我觉得很奇葩，很扯蛋，哈哈，可能奇葩的问题需要奇葩的方法，想出这个方法的同学其实还是很腻害的，膜拜！哈哈！！！下面来看这位同学的方法： 123NSString *title = [NSString stringWithFormat:@&quot;%ld秒后重试&quot;, self.count];self.getCheckCodeButton.titleLabel.text = title; // 这一句很重要，是关键，而且必须在setTitle之前，别问我为什么，我不知道，捂脸 捂脸 捂脸[self.getCheckCodeButton setTitle:title forState:UIControlStateDisabled]; 如注释所示，就是在setTitle之前，直接通过titleLabel给按钮标题赋值，然后再setTitle，这两行代买一个字都不能少，而且不需是这个顺序，setTitle断后。 这个方法虽然能解决问题，但对于有代码洁癖的人，怎么能接受这么奇葩的使用方式？？？于是通过高人指点，最终的完美解决方案诞生了…看方法三 方法三：先来看优雅的代码 12345NSString *title = [NSString stringWithFormat:@&quot;%ld秒后重试&quot;, self.count];[UIView performWithoutAnimation:^&#123; [self.getCheckCodeButton setTitle:title forState:UIControlStateDisabled]; [self.getCheckCodeButton layoutIfNeeded]; &#125;]; 现在我们先来谈谈出现闪烁问题的根本原因，通过xib创建的button，在setTitle的时候，默认添加了一个隐式的fade动画，使得title的更新是一个渐变的过程，而这个动画时间慢到了我们肉眼完全可以的感知的速度，于是出现了我们看到的闪烁，所以解决问题的关键，当然就是去禁用这个该死的动画了，而UIView的API里就已经提供了我们禁用隐式动画的block方法了，到此，问题完美解决！！！！ 多些高人指点，觉得有记录和分享价值，睡前坚持把字码起来，希望小伙伴们喜欢！！！","categories":[],"tags":[]},{"title":"谈一谈我对属性，成员变量，实例变量，以及传说中的@property，@synthesize，@dynamic的认识","slug":"谈一谈我对属性，成员变量，实例变量，以及传说中的-property，-synthesize，-dynamic的认识","date":"2017-06-14T09:11:18.000Z","updated":"2017-06-14T09:11:59.000Z","comments":true,"path":"2017/06/14/谈一谈我对属性，成员变量，实例变量，以及传说中的-property，-synthesize，-dynamic的认识/","link":"","permalink":"http://yoursite.com/2017/06/14/谈一谈我对属性，成员变量，实例变量，以及传说中的-property，-synthesize，-dynamic的认识/","excerpt":"","text":"一. 属性，成员变量，实例变量在讨论之前我先给大家推荐一个 NSObject 的类扩展 NSObject+DLIntrospection 利用 runtime，扩展了获取类的属性，实例变量，实例方法，类方法，协议protocol 等列表的方法，后面的讲解我们需要用到它。 1234567891011121314#import &lt;Foundation/Foundation.h&gt;@interface NSObject (DLIntrospection)+ (NSArray *)classes; // 获取所有的类名+ (NSArray *)properties; // 获取属性列表+ (NSArray *)instanceVariables; // 获取实例变量列表+ (NSArray *)classMethods; // 获取类方法列表（+方法）+ (NSArray *)instanceMethods; // 获取实例方法列表（-方法）+ (NSArray *)protocols; // 获取协议列表+ (NSDictionary *)descriptionForProtocol:(Protocol *)proto;+ (NSString *)parentClassHierarchy; // 当前类的继承关系@end 废话少说，先看代码.h 源码 123456@interface HMTestClass : NSObject&#123; NSString *_ivarInterface; // 实例变量，在iOS开发中也叫成员变量&#125;@property (nonatomic, copy) NSString *propertyInterface;@end 再看 .m 源码123456789@interface HMTestClass ()@property (nonatomic, copy) NSString *propertyImplementation;@end@implementation HMTestClass&#123; NSString *_ivarImplementation; // 实例变量，在iOS开发中也叫成员变量&#125;@end 最后咱们看看调试输出结果123456// 获取属性输出结果(lldb) po [HMTestClass properties]&lt;__NSArrayI 0x100200c40&gt;(@property (nonatomic, copy) NSString* propertyImplementation,@property (nonatomic, copy) NSString* propertyInterface) 12345678// 获取实例变量输出结果(lldb) po [HMTestClass instanceVariables]&lt;__NSArrayI 0x100300430&gt;(NSString* _ivarInterface,NSString* _ivarImplementation,NSString* _propertyInterface,NSString* _propertyImplementation) 看到这里，我们首先可以得出结论： 属性 即用 @property 声明的部分，它可以在 .h 文件里，也可以在 .m 文件里，在 .m 里即为私有属性； 而 实例变量 即为被包含在 @interface 和 @implementation 下的大括号里的，以及 @property 时编译器为我们自动生成的两部分组成； 我们还看到用 @property 声明的属性 propertyInterface 和 propertyImplementation，编译器自动给我们生成了对应以下划线 _ 开头的 实例变量，这一部分也是个学问，后一部分再讲 关于 成员变量 我认为就是 实例变量，两者等价，又或者仅仅只是 @interface 下的部分。当然有官方更准确的描述的，非常非常欢迎感谢前来指正！！！ 概括一下：咱们用比喻的修辞手法来说，属性 是个口袋，属性名称描述它是上衣口袋，裤兜，还是其他位置的口袋，没有有实际意义，只让外界看到有一个口袋，当然口袋也可以缝在里面（在 .m 文件里声明），只有自己知道，当然放在外面的，也有可能只是看起来像个口袋，不能装东西（.m 里使用了 @dynamic 但忘记自己实现 set get，后面再详细介绍），而 实例变量 就是在口袋里存放的实实在在的东西。 二. @property，@synthesize，@dynamic @property 属性声明关键字，有三个类别的关键词分别描述该属性的：线程限制，内存管理，读写权限三方面的表现，默认情况下，基本数据类型为 atomic, assign, readwrite，OC 对象为 atomic, strong, readwrite 若 .m 文件不使用 @synthesize 和 @dynamic，编译器会自动生成属性的 set get 方法，并生成 已下划线 _ 加属性名的实例变量； @synthesize @synthesize property; 这种情况下，编译器生成的实例变量没有了下滑下； @synthesize property = _ivar; 这种情况下，编译器不再生成实例变量，对 property 调用set get 实际操作的是 _ivar 实例变量，即这个口袋里放的是 _ivar; @dynamic @dynamic property; 编译器不会生成实例变量，同时也不会实现 set get 方法，需要开发者自己手写，如若忘记自己实现 set get，碰到对 set get 进行的调用的地方，程序会 crash，报unrecognized selector的异常 end","categories":[],"tags":[]},{"title":"HMExpressionEvaluator——一个使用简单又强大的表达式计算库","slug":"HMExpressionEvaluator——一个使用简单又强大的表达式计算库","date":"2017-06-14T09:03:23.000Z","updated":"2017-06-15T02:52:11.000Z","comments":true,"path":"2017/06/14/HMExpressionEvaluator——一个使用简单又强大的表达式计算库/","link":"","permalink":"http://yoursite.com/2017/06/14/HMExpressionEvaluator——一个使用简单又强大的表达式计算库/","excerpt":"","text":"demo下载地址 一. 简介 一个数学表达式计算器，能实现和 UIWebView 的 stringByEvaluatingJavaScriptFromString: 一样的计算效果，但效率要高很多，可以在子线程中执行； 基本全面覆盖 NSExpression 的 expressionForFunction:arguments 中的所有function，使用要比 NSExpression 简单很多，只需将注意力放大expression表达式的编辑上，将任意复杂度的表达式，通过eval:方法传入便可轻松得到计算结果； 支持复杂加减乘除四则运算，与或非逻辑运算，和大于小于等比较运算； 支持三目运算； 表达式中能自动识别处理的函数，基本全部覆盖NSExpression，有的未实现的，因为可以自己有数学表达式表达，比如 a+b，这个表达式计算最基本功能，无需通过函数调用来实现； 以上所述的计算类型在符合数学表达式逻辑的前提下，可以组合在一个表达式中，函数支持嵌套调用； 支持字符串相加（字符串拼接）； 开发者可以扩展自己的函数，通过构建 HMExpressionFunction 对象来声明自定义的函数，详细使用方式可以参考 demo。 二. 使用方式 引入头文件 1#import&quot;HMExpressionEvaluator.h&quot; **HMExpressionEvaluator.h** 文件中只声明了4个方法：&lt;br&gt; - -(id)eval:(NSString *)expression // 用于传入表达式进行计算并返回计算结果&lt;br&gt; - -(void)setCustomFunctions:(NSDictionary *)customFunctions // 用于给开发者注册自定义方法&lt;br&gt; - -(void)setDateFormatter:(NSDateFormatter *)dateFormatter // 设置支持的日期格式，默认只支持 yyyy-MM-dd HH:mm:ss 格式&lt;br&gt; - -(void)withoutFunctionTransfer:(BOOL)withoutFunction; // 不支持函数调用，仅用于计算纯数学表达式，默认为支持函数调用&lt;br&gt;&lt;br&gt; 开发者仅需通过这4个 API 来使用表达式计算全部功能 1234567891011121314151617181920212223242526272829303132333435// HMExpressionEvaluator.h @interface HMExpressionEvaluator : NSObject#pragma mark - API/** * 表达式计算 * * @param expression 需要计算的表达式 * * @return 计算结果 */- (id)eval:(NSString *)expression;/** * 设置开发者自定义的函数集 * * @param customFunctions 每个函数用 HMExpressionCustomFunction 对象来描述，以函数名为 key * */- (void)setCustomFunctions:(NSDictionary *)customFunctions;/** * 设置支持的日期格式，默认只支持 yyyy-MM-dd HH:mm:ss 格式 * * @param dateFormat 日期格式 */- (void)setDateFormat:(NSString *)dateFormat;/** * 不支持函数调用，仅用于计算纯数学表达式，默认为支持函数调用 */- (void)withoutFunctionTransfer:(BOOL)withoutFunction;@end 具体使用方式 支持的数学运算操作符和操作数类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127typedef NS_ENUM(NSInteger, HMExpressionNodeType)&#123; /** * 未知 0 */ Unknown, /** * + 加 */ Plus, /** * - 减 */ Subtract, /** * * 乘 */ MultiPly, /** * / 除 */ Divide, /** * ( 左括号 */ LParentheses, /** * ) 右括号 */ RParentheses, /** * % 求模,取余 */ Mod, /** * ^ 幂运算 */ Power, /** * &lt;&lt; 左移位 */ LShift, /** * &gt;&gt; 右移位 */ RShift, /** * &amp; 按位与 */ BitwiseAnd, /** * | 按位或 */ BitwiseOr, /** * &amp;&amp; 逻辑与 */ And, /** * || 逻辑或 */ Or, /** * ! 逻辑非 */ Not, /** * == 比较等 */ Equal, /** * != 或 &lt;&gt; 比较不等 */ Unequal, /** * &gt; 比较大于 */ GT, /** * &lt; 比较小于 */ LT, /** * &gt;= 比较大于等于 */ GTOrEqual, /** * &lt;= 比较小于等于 */ LTOrEqual, /** * 数值 */ Numeric, /** * 字符串 */ String, /** * 日期时间 */ Datetime&#125;; 使用示例 1234567891011121314// 简单四则运算[HMExpressionEvaluator eval:@&quot;22 + 33 * 66 + 3^5&quot;]; // 3^5 3的5次方// 简单比较运算[HMExpressionEvaluator eval:@&quot;5 &lt; 6&quot;];// 逻辑运算[HMExpressionEvaluator eval:@&quot;5 &lt; 3 || 6 &gt; 5)&quot;];// 位运算[HMExpressionEvaluator eval:@&quot;4 &lt;&lt; 5&quot;];// 字符串相加[HMExpressionEvaluator eval:@&quot;\\&quot;Hello\\&quot; + \\&quot; \\&quot; + \\&quot;World\\&quot; &lt;&lt; 5&quot;]; 包含函数的运算 支持的函数清单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 // 逻辑运算类 ternaryOperation(5&lt;7, \\&quot;真\\&quot;, \\&quot;假\\&quot;) // 三目表达式 日期类处理方法, 日期字符串格式要求为：yyyy-MM-dd或者yyyy-MM-dd HH:mm:ss dateDiff(差值类型, 较早日期, 较晚日期) // 时间差值 getYear(date) // 获取日期中的年份 getQuarter(date) // 获取日期中的第几季度 getLocalQuarter(date) // 获取日期中的中文第几季度 getMonth(date) // 获取日期中的月份 getLocalMonth(date) // 获取日期中的中文月份 getWeek(date) // 获取日期中的第几周 getLocalWeek(date) // 获取日期中的中文第几周 getDayOfWeek(date) // 获取日期中的星期几 getLocalDayOfWeek(date) // 获取日期中的中文星期几 getDay(date) // 获取日子 getLocalDay // 获取中文日子 now() // 获取现在时间 // 数值类 getLocalMoney(digit) // 将数值转换为大写金额 round(digit) // 数值四舍五入 ceil(digit) // 数值0舍1入 trunc(digit) // 向下取整 floor(digit) // 向下取整 abs(digit) // 求绝对值 sqrt(digit) // 开平方 log(digit) // 底数为e对数 ln(digit) // 底数为e对数 log10(digit) // 底数为10对数 log2(digit) // 底数为2对数 raiseToPower(x, n) // 计算 x 的 n 次方 exp(digit) // 求e的x次方 bitwiseXor(a, b) // a 异或 b onesComplement(a) // a 的补码 average(digit, digit, ...) // 求平均 sum(digit, digit, ...) // 求和 count(digit, digit, ...) // 计数 min(digit, digit, ...) // 找最小值 max(digit, digit, ...) // 找最大值 median(digit, digit, ...) // 找中值 mode(digit, digit, ...) // 一数组或数据区域中出现频率最多的数值 stddev(digit, digit, ...) // 样本标准偏差 random(void) // 获取随机数小数 randomn(digit) // 获取随机数整数 // 字符串类 contains(&quot;待检字符串&quot;, &quot;被包含字符串&quot;) // 检查包含子字符串 unContains(&quot;待检字符串&quot;, &quot;不被包含字符串&quot;) // 检查不包含子字符串 lowercase(&quot;字符串&quot;) // 转小写 uppercase(&quot;字符串&quot;) // 转大写 ``` 2. 调用方式 ```Objective-C // 三目运算函数 [HMExpressionEvaluator eval:@&quot;ternaryOperation(5&lt;7, \\&quot;真\\&quot;, \\&quot;假\\&quot;)&quot;]; // 获取大写金额 [HMExpressionEvaluator eval:@&quot;getLocalMoney(10086)&quot;]; // 复杂混合运算表达式 [HMExpressionEvaluator eval:@&quot;dateDiff(\\&quot;dd\\&quot;, \\&quot;2016-12-17\\&quot;, now()) * 10 - getYear(now()) + max(11, 22,33,1000) * sqrt(floor(1000.445))&quot;]; 自定义函数的使用，以 demo 为例： 第一步：自定义方法的OC实现 demo 中在 ViewController.m 实现了如下四个方法，可以看到返回时，均构建了 HMExpressionCustomFunctionResult 类实例来返回，这是必须的； 方法中传入的 param 会根据表达式中调用函数时括号内传入的参数情况解析成字符串，一维数组，或者二维数组，具体规则看如下代码段的注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#pragma mark - 自定义函数测试/* * 不带参函数 * 在表达式中写入 test1() * * @return 创建 HMExpressionFunctionResult 实例，返回函数运行结果 */- (HMExpressionCustomFunctionResult *)test1&#123; return [[HMExpressionCustomFunctionResult alloc] initWithResult:@&quot;测试不带参函数&quot; dataType:HMExpressionCustomFunctionResultDataTypeString] ;&#125;/* * 带一个加单参数的函数 * * @param param 如在表达式中写：test2(123) 则此处 param 为: @&quot;123&quot; * * @return 创建 HMExpressionFunctionResult 实例，返回函数运行结果 */- (HMExpressionCustomFunctionResult *)test2:(id)param&#123; return [[HMExpressionCustomFunctionResult alloc] initWithResult:[NSString stringWithFormat:@&quot;测试带参函数，传入参数为：%@&quot;, param] dataType:HMExpressionCustomFunctionResultDataTypeString];&#125;/* * 一维多参函数，将所有参数拼接成一个字符串 * 如表达式中写：test3(123, 456, 789...) 数量根据自己的需要来定 * * @param param 此处得到 param 为一维数组 @[@&quot;123&quot;, @&quot;456&quot;, @&quot;789&quot;...] * * @return 创建 HMExpressionFunctionResult 实例，返回函数运行结果 */- (HMExpressionCustomFunctionResult *)test3:(id)param&#123; // 将所有参数拼接成一个字符串 NSMutableString *result = [NSMutableString string]; for(NSString *str in param) &#123; [result appendString:str]; &#125; return [[HMExpressionCustomFunctionResult alloc] initWithResult:result dataType:HMExpressionCustomFunctionResultDataTypeString];&#125;/* * 二维多参函数，函数功能为将所有参数拼接为字符串 * 如表达式中写：test3(123, [456, 789], @&quot;333&quot;, [234]...) 数量根据自己的需要来定 * * @param param 此处得到 param 为二维数组 @[@&quot;123&quot;, @[@&quot;456&quot;, @&quot;789&quot;], @&quot;333&quot;, @[@&quot;234&quot;]...] * * @return 创建 HMExpressionFunctionResult 实例，返回函数运行结果 */- (HMExpressionCustomFunctionResult *)test4:(id)param&#123; NSMutableString *result = [NSMutableString string]; for(id obj in param) &#123; if([obj isKindOfClass:[NSArray class]]) &#123; for(NSString *str in (NSArray *)obj) &#123; [result appendString:str]; &#125; &#125; else &#123; [result appendString:obj]; &#125; &#125; return [[HMExpressionCustomFunctionResult alloc] initWithResult:result dataType:HMExpressionCustomFunctionResultDataTypeString];&#125; 第二步：构建 HMExpressionCustomFunction 实例 如下代码将上述四个 test 方法分别构建一个 HMExpressionCustomFunction 实例来进行描述，并以用于表达式调用的函数名为 key 存入字典，准备注入表达式解析计算器中。 12345678910111213141516171819202122232425262728- (NSDictionary *)customFunctions&#123; if(!_customFunctions) &#123; _customFunctions = [NSMutableDictionary dictionary]; // test1 无参函数 HMExpressionCustomFunction *function = [[HMExpressionCustomFunction alloc] initWithFunctionName:@&quot;test1&quot; selector:@selector(test1) target:self]; [_customFunctions setObject:function forKey:function.functionName]; // test2 带一个参数的函数 function = [[HMExpressionCustomFunction alloc] initWithFunctionName:@&quot;test2&quot; selector:@selector(test2:) target:self]; [_customFunctions setObject:function forKey:function.functionName]; // test3 带多个一维参数的函数 function = [[HMExpressionCustomFunction alloc] initWithFunctionName:@&quot;test3&quot; selector:@selector(test3:) target:self]; [_customFunctions setObject:function forKey:function.functionName]; // test4 带多个二维参数的函数 function = [[HMExpressionCustomFunction alloc] initWithFunctionName:@&quot;test4&quot; selector:@selector(test4:) target:self]; [_customFunctions setObject:function forKey:function.functionName]; &#125; return _customFunctions;&#125; 第三步：将构建好的 HMExpressionCustomFunction 实例注入表达式解析计算器 代码如下，即在 demo 中点击 “计算” 按钮时执行的代码 123456789101112131415161718/* * 创建表达式计算器对象 */- (HMExpressionEvaluator *)evaluator&#123; if(!_evaluator) &#123; _evaluator = [[HMExpressionEvaluator alloc] init]; [_evaluator setCustomFunctions:self.customFunctions]; // 注入自定义函数集 // 默认就是这个格式 // [_evaluator setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; // 默认就是 false，即表达式支持函数调用，当表达式不需要函数调用是，调用该方法置为 true，可以调高运算效率 // [_evaluator withoutFunctionTransfer:false]; &#125; return _evaluator;&#125; 最后上图看看运行效果 感兴趣请下载demo研究，运行后，点击快速测试，快速一睹 HMExpressionValuator 的风采吧！ demo下载地址 意见建议请联系： QQ: 247159603 简书： JZ_Stone","categories":[],"tags":[]}]}